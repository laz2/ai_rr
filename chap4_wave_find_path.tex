\section{Созданиe программы wave\_find\_path}

В этом разделе мы будем создавать программу поиска минимального пути с
использованием библиотеки libsc. По примененному алгоритму поиска
минимального пути и своей структуре программа из этого раздела будет
похожа на программу из раздела~\ref{Desc_wave_find_path}. Самым важным
отличием будет то, что обработка информации будет происходить в
sc-памяти.

Начнем мы с подготовке sc-памяти для работы алгоритма.

\subsection{Инициализация и подготовка sc-памяти}

Создадим набросок функции \lstinline|main| для начала работы с
sc-памятью:
\begin{lstlisting}[texcl]
// Необходимые заголовычные файлы
#include <libsc.h>
#include <pm_keynodes.h>

// $\dots$

int main(int argc, char **argv)
{
    // Инициализация libsc.
    sc_session *system = libsc_init();

    // Теперь мы получили пустую sc-память.

    // Создание sc-сегмента \verb|/proc/keynode| и
    // системных ключевых узлов в нем (например, \verb|1_|, \verb|2_| и т.д.)
    // Эту функцию нужно вызывать обязательно.
    pm_keynodes_init(system);

    //
    // Здесь мы будем производить основную работу с sc-памятью.
    //

    // Деинициализируем libsc.
    libsc_deinit();

    return 0;
}
\end{lstlisting}

Я думаю, что комментарии к приведенному выше листингу излишне. Если же
у вас возникли трудности, то обратитесь к
разделу~\ref{Begin_with_libsc}, в котором были описаны все
использованные функции.

Мы получили sc-память с системными ключевыми узлами, однако для работы
алгоритма необходимы еще и такие ключевые узлы, как
\idtf{неориентированный граф}, \idtf{вершина\_}, \idtf{ребро\_} и др.,
т.е. ключевые узлы базы знаний по теории графов
(см. раздел~\ref{sec:-Graph_onto_concept_list}).Однако, по данному
пункту есть два отличия от раздела~\ref{sec:-Graph_onto_concept_list}.

Во-первых, реализация sc-памяти имеет сегментную организацию, поэтому
необходимо выбрать sc-сегмент, в котором будут храниться ключевые узлы
базы знаний по теории графов. Для этого мы бдуем использовать sc-сегмент
\verb|/graphs_theory/keynode|.

Во-вторых, реализация sc-памяти работает только с кодировкой CP1251, а
мной используется для написания исходных текстов кодировка UTF-8,
поэтому при решении нашей задачи не очень удобно использовать русские
идентификаторы ключевых узлов. Таким образом, мы будем использовать
английские идентификаторы ключевых узлов, например:
\begin{itemize}
\item \idtf{вершина\_} <=> \idtf{vertex\_}
\item \idtf{связка\_} <=> \idtf{connective\_}
\item \idtf{ребро\_} <=> \idtf{edge\_}
\item \idtf{дуга\_} <=> \idtf{arc\_}
\item \idtf{неориентированный граф} <=> \idtf{undirected graph}
\item \idtf{ориентированный граф} <=> \idtf{directed graph}
\item \idtf{простая цепь*} <=> \idtf{simple trail*}
\end{itemize}

Теперь можно переходить к организации создания и работы с ключевыми
узлами. Для этого нам понадобится функция создания сегмента по полному
URI, которая определена в файле \verb|segment_utils.h| следующим
образом:
\begin{lstlisting}[texcl]
/// Функция при помощи sc-сессии @p s создает sc-сегмент по полному URI @p uri
/// c созданием всех промежуточных директорий.
///
/// Если создание прошло успешно, то sc-сегмент, иначе 0.
sc_segment *create_segment_full_path(sc_session *s, const sc_string &uri);
\end{lstlisting}

Пришло время написать код, который обеспечивает работу с ключевыми
узлами. В листинге ниже представлено пространство имен
\lstinline|graph_theory|, которое содержит объявление ключевых узлов и
функцию для их инициализации:
\begin{lstlisting}[texcl]
// Для использования \verb|create_segment_full_path|
#include <segment_utils.h>

// $\dots$

/// Пространство имен ключевых узлов по теории графов.
///
/// Для начала работы необходимо вызвать функцию \verb|graph_theory::init|,
/// передав в качестве параметра системную сессию.
/// После этого, например, чтобы обратиться к узлу \idtf{вершина\_},
/// достаточно написать \verb|graph_keynodes::vertex_|.
namespace graph_theory
{
    /// URI сегмента ключевых узлов.
    const char *segment_uri = "/graph_theory/keynode";

    /// Созданный сегмент ключевых узлов.
    sc_segment *segment;

    /// Массив идентификаторов ключевых узлов.
    const char *idtfs[] = {
        "vertex_",          // \idtf{вершина\_}
        "connective_",      // \idtf{связка\_}
        "edge_",            // \idtf{ребро\_}
        "arc_",             // \idtf{дуга\_}
        "undirected graph", // \idtf{неориентированный граф}
        "directed graph",   // \idtf{ориентированный граф}
        "simple trail*"     // \idtf{простая цепь*}
    };

    /// Массив sc-адресов созданных ключевых узлов.
    sc_addr keynodes[sizeof(uris) / sizeof(const char*)];

    /// Ссылки на ключевые узлы для более удобной работы.
    /// @\{
    const sc_addr &vertex           = keynodes[0];
    const sc_addr &connective_      = keynodes[1];
    const sc_addr &edge_            = keynodes[2];
    const sc_addr &arc_             = keynodes[3];
    const sc_addr &undirected_graph = keynodes[4];
    const sc_addr &directed_graph   = keynodes[5];
    const sc_addr &simple_trail     = keynodes[6];
    /// @\}

    /// Производит создание ключевых узлов при помощи сессии @p \verb|s|
    /// и готовит их к работе.
    void init(sc_session *s)
    {
        // Сперва создадим сегмент <<\verb|/graph_theory/keynode|>> для
        // ключевых узлов.
        segment = create_segment_full_path(s, segment_uri);

        // Пробежимся по массиву идентификаторов ключевых узлов \verb|idtfs|
        // и создадим каждый ключевой узел.
        // Создаваемые узлы будем заносить в массив \verb|keynodes|.
        for (int i = 0; i < sizeof(keynodes) / sizeof(sc_addr); ++i) {
            keynodes[i] = s->create_el(segment, SC_N_CONST);
            s->set_idtf(keynodes[i], idtfs[i]);
        }
    }
}
\end{lstlisting}

С учетом написанного кода для работы с ключевыми узлами, продолжим
работу над функцией \lstinline|main|. Во-первых, до начала работы
алгоритма нам необходимо в этой функции инициализировать ключевые узлы
теории графов. Во-вторых, создать пользовательскую сессию для работы
алгоритма. В-третьих, так как в рамках только что созданной
пользовательской сессии нет открытых сегментов, открыть сегменты
ключевых узлов в созданной сессии. Таким образом, окончательный
вариант разрабатываемой функции будет следующим:
\begin{lstlisting}[texcl]
int main(int argc, char **argv)
{
    // Инициализация libsc.
    sc_session *system = libsc_init();

    // Теперь мы получили пустую sc-память.

    // Создание sc-сегмента \verb|/proc/keynode| и
    // системных ключевых узлов в нем (например, \verb|1_|, \verb|2_| и т.д.)
    // Эту функцию нужно вызывать обязательно.
    pm_keynodes_init(system);

    // Инициализируем ключевые узлы базы знаний по теории графов.
    graph_theory::init(system);

    // Создадим пользовательскую сессию для работы алгоритма.
    sc_session *session = libsc_login();

    // Откроем сегменты системных ключевых узлов и ключевых узлов
    // базы знаний по теории графов в рамках пользовательской сессии.
    session->open_segment("/proc/keynode");
    session->open_segment(graph_theory::segment_uri);

    //
    // Запуск алгоритма.
    //

    // Закроем пользовательскую сессию.
    session->close();

    // Деинициализируем libsc.
    libsc_deinit();

    return 0;
}
\end{lstlisting}

Все готово для написания и запуска алгоритма, но сейчас мы будем
рассматривать вспомогательные функции для генерации и вывода на
консоль неориентированных графов.

\subsection{Генерация неориентированного графа}

\subsection{Вывод на консоль неориентированного графа}

Для вывода неориентированного графа на консоль нам надо будет
предпринять следующие шаги:
\begin{enumerate}
\item вывести на консоль каждое ребро графа вместе с инцидентными
  вершинами и запомнить выведенные вершины;
\item вывести на консоль те вершины, которые еще не были выведены.
\end{enumerate}

Приступим к написанию фукнции \lstinline|print_graph|, заголовочная
часть которой выглядит следующим образом:
\begin{lstlisting}[texcl]
/// Выводит на консоль неориентированный граф @p \verb|graph|.
///
/// @param s     сессия, при помощи которой будет производиться работа с sc-памятью.
/// @param graph неориентированный граф для вывода на консоль.
void print_graph(sc_session *s, sc_addr graph);
\end{lstlisting}

Для начала определимся со структурой данных, в которой будем хранить
уже выведенные на консоль вершины. Можно было бы, сохраняя чистоту
подхода, использовать для хранения такой информации множество в
sc-памяти. Однако, на мой взгляд, в данном случае будет достаточно
использовать STL-контейнер \lstinline|std::set|, который будет хранить
sc-адреса вершин. Для самых распространнех STL-контейнеров, которые
хранят данные типа \lstinline|sc_addr|, в файле \verb|sc_types.h|
объявлены \lstinline|typedef|'ы. Нас будет интересовать
\lstinline|addr_set| - \lstinline|typedef| для
\lstinline|std::set<sc_addr>|. Таким образом, начало функции
будет следующим:
\begin{lstlisting}[texcl]
void print_graph(sc_session *s, sc_addr graph)
{
    assert(s);
    assert(graph);

    addr_set printed_vertexes; // множество выведенных вершин

    // $\dots$
}
\end{lstlisting}

Следующим шагом будет вывод на консоль ребер и инцидентных им
вершин. Так как граф хранится в sc-памяти, то нам необходимо
использовать ее базовые поисковые механизмы
(раздел~\ref{sec:libsc_search_basic}).

Ребра входят в граф с атрибутом \idtf{ребро\_}, поэтому для их
перебора мы будем использовать одно из ограничений поиска
пятиэлементных sc-конструкций(см. рис~\ref{fig:5_sc_constr}). В нашем
случае фиксированными являются 1-ый (узел графа, т.е. параметр
\lstinline|graph|) и 5-ый (атрибут \idtf{ребро\_}) элементы
пятиэлементной sc-конструкции. Следовательно, мы будем использовать
ограничение \lstinline|CONSTR_5_f_a_a_a_f|. Это ограничение является
одним из самых часто используемых, когда 2-ой и 4-ый элементы являются
константными позитивными sc-дугами, т.е. подходят под маску типа
\lstinline+SC_A_CONST|SC_POS+. В нашем случае это так и есть, а для
3-го элемента будем использовать маску типа 0, т.е. он может быть
любого типа. Ниже приведен код создания итератора по ребрам:
\begin{lstlisting}[texcl]
void print_graph(sc_session *s, sc_addr graph)
{
    // $\dots$

    // 1. Создание итератора по ребрам.
    sc_iterator* edges_it = s->create_iterator(
        sc_constraint_new(
            CONSTR_5_f_a_a_a_f,
            graph,
            SC_A_CONST|SC_POS,
            0,
            SC_A_CONST|SC_POS,
            graph_theory::edge_
    ), true);

    // $\dots$
}
\end{lstlisting}

Начнем создания цикла по ребрам. Для него логично использовать макрос
\lstinline|sc_for_each|:
\begin{lstlisting}[texcl]
void print_graph(sc_session *s, sc_addr graph)
{
    // $\dots$

    // 2. Цикл по всем результатам поиска.
    sc_for_each (edges_it) {
        sc_addr edge = edges_it->value(2);

        // Получим вершины, инцидентные ребру \verb|edge|.
        sc_addr v1 = 0, v2 = 0;
        get_edge_vertexes(s, edge, v1, v2);

        // Выведем ребро вместе с инцидентными вершинами.
        std::cout << s->get_idtf(v1) << " -- " << s->get_idtf(v2) << '\n';

        // Запомним вершины, как выведенные.
        printed_vertexes.insert(v1);
        printed_vertexes.insert(v2);
    }

    // $\dots$
}
\end{lstlisting}

Последним этапом функции \lstinline|print_graph| является вывод тех
вершин, которые еще не были выведены на консоль, т.е. не входят во
множество \lstinline|printed_vertexes|. Для этого необходимо
организовать цикл по всем вершинам.  Вершины входят в граф с атрибутом
\idtf{вершина\_}. Tаким образом, нам подходит уже знакомое ограничение
\lstinline|CONSTR_5_f_a_a_a_f|, которому в качестве атрибута мы
передадим не \lstinline|graph_theory::edge_|, как в случае с перебором
ребер, а \lstinline|graph_theory::vertex_|. Разрабатываемый цикл будет
следующим:
\begin{lstlisting}[texcl]
void print_graph(sc_session *s, sc_addr graph)
{
    // $\dots$

    // 3. Вывод вершин, которые не имеют инцидентных ребер.
    sc_iterator *vertexes_it = s->create_iterator(
        sc_constraint_new(
            CONSTR_5_f_a_a_a_f,
            graph,
            SC_A_CONST|SC_POS,
            0,
            SC_A_CONST|SC_POS,
            graph_theory::vertex_
    ), true);
    sc_for_each (vertexes_it) {
        sc_addr vertex = vertexes_it->value(2);

        // Проверим, входит ли вершина в множество \verb|printed_vertexes|
        if(printed_vertexes.find(vertex) == printed_vertexes.end())
            std::cout << s->get_idtf(vertex) << '\n';
    }
}
\end{lstlisting}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 

