\section{Созданиe программы wave\_find\_path}

В этом разделе мы будем создавать программу поиска минимального пути с
использованием библиотеки libsc. По примененному алгоритму поиска
минимального пути и своей структуре программа из этого раздела будет
похожа на программу из раздела~\ref{Desc_wave_find_path}. Самым важным
отличием будет то, что обработка информации будет происходить в
sc-памяти.

Начнем мы с подготовке sc-памяти для работы алгоритма.

\subsection{Инициализация и подготовка sc-памяти}

Создадим набросок функции \lstinline|main| для начала работы с
sc-памятью:
\begin{lstlisting}[texcl]
// Необходимые заголовычные файлы
#include <libsc.h>
#include <pm_keynodes.h>

// $\dots$

int main(int argc, char **argv)
{
    // Инициализация libsc.
    sc_session *system = libsc_init();

    // Теперь мы получили пустую sc-память.

    // Создание sc-сегмента \verb|/proc/keynode| и
    // системных ключевых узлов в нем (например, \verb|1_|, \verb|2_| и т.д.)
    // Эту функцию нужно вызывать обязательно.
    pm_keynodes_init(system);

    //
    // Здесь мы будем производить основную работу с sc-памятью.
    //

    // Деинициализируем libsc.
    libsc_deinit();

    return 0;
}
\end{lstlisting}

Я думаю, что комментарии к приведенному выше листингу излишне. Если же
у вас возникли трудности, то обратитесь к
разделу~\ref{Begin_with_libsc}, в котором были описаны все
использованные функции.

Мы получили sc-память с системными ключевыми узлами, однако для работы
алгоритма необходимы еще и такие ключевые узлы, как
\idtf{неориентированный граф}, \idtf{вершина\_}, \idtf{ребро\_} и др.,
т.е. ключевые узлы базы знаний по теории графов
(см. раздел~\ref{sec:-Graph_onto_concept_list}).Однако, по данному
пункту есть два отличия от раздела~\ref{sec:-Graph_onto_concept_list}.

Во-первых, реализация sc-памяти имеет сегментную организацию, поэтому
необходимо выбрать sc-сегмент, в котором будут храниться ключевые узлы
базы знаний по теории графов. Для этого мы бдуем использовать sc-сегмент
\verb|/graphs_theory/keynode|.

Во-вторых, реализация sc-памяти работает только с кодировкой CP1251, а
мной используется для написания исходных текстов кодировка UTF-8,
поэтому при решении нашей задачи не очень удобно использовать русские
идентификаторы ключевых узлов. Таким образом, мы будем использовать
английские идентификаторы ключевых узлов, например:
\begin{itemize}
\item \idtf{вершина\_} <=> \idtf{vertex\_}
\item \idtf{связка\_} <=> \idtf{connective\_}
\item \idtf{ребро\_} <=> \idtf{edge\_}
\item \idtf{дуга\_} <=> \idtf{arc\_}
\item \idtf{неориентированный граф} <=> \idtf{undirected graph}
\item \idtf{ориентированный граф} <=> \idtf{directed graph}
\item \idtf{простая цепь*} <=> \idtf{simple trail*}
\end{itemize}

Теперь можно переходить к организации создания и работы с ключевыми
узлами. Для этого нам понадобится функция создания сегмента по полному
URI, которая определена в файле \verb|segment_utils.h| следующим
образом:
\begin{lstlisting}[texcl]
/// Функция при помощи sc-сессии @p s создает sc-сегмент по полному URI @p uri
/// c созданием всех промежуточных директорий.
///
/// Если создание прошло успешно, то sc-сегмент, иначе 0.
sc_segment *create_segment_full_path(sc_session *s, const sc_string &uri);
\end{lstlisting}

Пришло время написать код, который обеспечивает работу с ключевыми
узлами. В листинге ниже представлено пространство имен
\lstinline|graph_theory|, которое содержит объявление ключевых узлов и
функцию для их инициализации:
\begin{lstlisting}[texcl]
// Для использования \verb|create_segment_full_path|
#include <segment_utils.h>

// $\dots$

/// Пространство имен ключевых узлов по теории графов.
///
/// Для начала работы необходимо вызвать функцию \verb|graph_theory::init|,
/// передав в качестве параметра системную сессию.
/// После этого, например, чтобы обратиться к узлу \idtf{вершина\_},
/// достаточно написать \verb|graph_keynodes::vertex_|.
namespace graph_theory
{
    /// URI сегмента ключевых узлов.
    const char *segment_uri = "/graph_theory/keynode";

    /// Созданный сегмент ключевых узлов.
    sc_segment *segment;

    /// Массив идентификаторов ключевых узлов.
    const char *idtfs[] = {
        "vertex_",          // \idtf{вершина\_}
        "connective_",      // \idtf{связка\_}
        "edge_",            // \idtf{ребро\_}
        "arc_",             // \idtf{дуга\_}
        "undirected graph", // \idtf{неориентированный граф}
        "directed graph",   // \idtf{ориентированный граф}
        "simple trail*"     // \idtf{простая цепь*}
    };

    /// Массив sc-адресов созданных ключевых узлов.
    sc_addr keynodes[sizeof(uris) / sizeof(const char*)];

    /// Ссылки на ключевые узлы для более удобной работы.
    /// @\{
    const sc_addr &vertex           = keynodes[0];
    const sc_addr &connective_      = keynodes[1];
    const sc_addr &edge_            = keynodes[2];
    const sc_addr &arc_             = keynodes[3];
    const sc_addr &undirected_graph = keynodes[4];
    const sc_addr &directed_graph   = keynodes[5];
    const sc_addr &simple_trail     = keynodes[6];
    /// @\}

    /// Производит создание ключевых узлов при помощи сессии @p \verb|s|
    /// и готовит их к работе.
    void init(sc_session *s)
    {
        // Сперва создадим сегмент <<\verb|/graph_theory/keynode|>> для
        // ключевых узлов.
        segment = create_segment_full_path(s, segment_uri);

        // Пробежимся по массиву идентификаторов ключевых узлов \verb|idtfs|
        // и создадим каждый ключевой узел.
        // Создаваемые узлы будем заносить в массив \verb|keynodes|.
        for (int i = 0; i < sizeof(keynodes) / sizeof(sc_addr); ++i) {
            keynodes[i] = s->create_el(segment, SC_N_CONST);
            s->set_idtf(keynodes[i], idtfs[i]);
        }
    }
}
\end{lstlisting}

С учетом написанного кода для работы с ключевыми узлами, продолжим
работу над функцией \lstinline|main|. Во-первых, до начала работы
алгоритма нам необходимо в этой функции инициализировать ключевые узлы
теории графов. Во-вторых, создать пользовательскую сессию для работы
алгоритма. В-третьих, так как в рамках только что созданной
пользовательской сессии нет открытых сегментов, открыть сегменты
ключевых узлов в созданной сессии. Таким образом, окончательный
вариант разрабатываемой функции будет следующим:
\begin{lstlisting}[texcl]
int main(int argc, char **argv)
{
    // Инициализация libsc.
    sc_session *system = libsc_init();

    // Теперь мы получили пустую sc-память.

    // Создание sc-сегмента \verb|/proc/keynode| и
    // системных ключевых узлов в нем (например, \verb|1_|, \verb|2_| и т.д.)
    // Эту функцию нужно вызывать обязательно.
    pm_keynodes_init(system);

    // Инициализируем ключевые узлы базы знаний по теории графов.
    graph_theory::init(system);

    // Создадим пользовательскую сессию для работы алгоритма.
    sc_session *session = libsc_login();

    // Откроем сегменты системных ключевых узлов и ключевых узлов
    // базы знаний по теории графов в рамках пользовательской сессии.
    session->open_segment("/proc/keynode");
    session->open_segment(graph_theory::segment_uri);

    //
    // Запуск алгоритма.
    //

    // Закроем пользовательскую сессию.
    session->close();

    // Деинициализируем libsc.
    libsc_deinit();

    return 0;
}
\end{lstlisting}

Все готово для написания и запуска алгоритма, но сейчас мы будем
рассматривать вспомогательные функции для генерации и вывода на
консоль неориентированных графов.

\subsection{Генерация неориентированного графа}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
